import React, { useState, useEffect, useRef, useMemo } from "react";
import { useRecoilValue ,useRecoilState} from "recoil";
import HeaderSelect from "../components/water_headerSection";
import GeoJSON from "ol/format/GeoJSON";
import LocationOnIcon from "@mui/icons-material/LocationOn";
import YearSlider from "./yearSlider";
import PrecipitationStackChart from "./PrecipitationStackChart.jsx";
import CroppingIntensityStackChart from "./CroppingIntensityStackChart.jsx";
import { yearAtomFamily } from "../store/locationStore";
import NDVIChart from "./NDVIChart.jsx";
import WaterAvailabilityChart from "./WaterAvailabilityChart";
import { useLocation, useNavigate } from "react-router-dom";
import DroughtChart from "./droughtchart.jsx";
import TopSection from "./autogenerated_header_text.jsx";
import TableView from "./tableView.jsx";
import { WATER_DASHBOARD_CONFIG } from "../config/dashboard_configs/waterDashboard.config.js";
import DashboardBasemap from "./dashboard_basemap.jsx";
import { useGlobalWaterData } from "../store/useGlobalWaterData";
import { waterGeoDataAtom, waterMwsDataAtom, zoiFeaturesAtom,selectedWaterbodyForTehsilAtom,tehsilZoiFeaturesAtom,tehsilDroughtDataAtom } from "../store/locationStore.jsx";

const WaterProjectDashboard = () => {
  const [selectedWaterbody, setSelectedWaterbody] = useState(null);
  const [mapClickedWaterbody, setMapClickedWaterbody] = useState(null);
  const [selectedFeature, setSelectedFeature] = useState(null);
  const [zoiArea, setZoiArea] = useState(null);
  const [waterbodyLegend, setWaterbodyLegend] = useState(false);
  const [zoiLegend, setZoiLegend] = useState(false);
  const [terrainLegend, setTerrainLegend] = useState(false);
  const [drainageLegend, setDrainageLegend] = useState(false);
  const [infoText, setInfoText] = useState("");
  const [infoAnchor, setInfoAnchor] = useState(null);
  const [infoOpen, setInfoOpen] = useState(false);
  const [openInfoKey, setOpenInfoKey] = useState(null);
  const [impactYear, setImpactYear] = useState({ pre: null, post: null });
  const [autoOpened, setAutoOpened] = useState(false);

  const lulcYear1 = useRecoilValue(yearAtomFamily("map1"));
  const lulcYear2 = useRecoilValue(yearAtomFamily("map2"));

  const [sortField, setSortField] = useState(null);
  const [sortOrder, setSortOrder] = useState("asc");
  const [searchText, setSearchText] = useState("");
  const [waterbodySearch, setWaterbodySearch] = useState("");
  const [selectedMWSFeature, setSelectedMWSFeature] = useState(null);

  const [organization, setOrganization] = useState(null);
  const [project, setProject] = useState(null);
  const [anchorEl, setAnchorEl] = useState(null);
  const [filterType, setFilterType] = useState("");
  const [loadingData, setLoadingData] = useState(true);

  const [tehsilGeoData, setTehsilGeoData] = useState(null);
  const [tehsilSelectedFeature, setTehsilSelectedFeature] = useState(null);
  const [mwsFromLocalStorage, setMwsFromLocalStorage] = useState(null);

  const [selectedWaterbodyForTehsil, setSelectedWaterbodyForTehsil] =
  useRecoilState(selectedWaterbodyForTehsilAtom);

  const tehsilDrought = useRecoilValue(tehsilDroughtDataAtom);

  const [filters, setFilters] = useState({
    state: [],
    district: [],
    block: [],
    village: [],
  });

  const location = useLocation();
  const navigate = useNavigate();

  // Extract URL parameters 
  const params = new URLSearchParams(location.search);
  const typeParam = params.get("type"); // "project" | "tehsil"

  const storedProject = JSON.parse(localStorage.getItem("selectedProject"));
  const projectNameParam = storedProject?.label || params.get("project_name") || null;
  const projectIdParam = storedProject?.value || null; 

  const stateParam = params.get("state");
  const districtParam = params.get("district");
  const blockParam = params.get("block");

  const waterbodyParam = params.get("waterbody");
  const mode = typeParam === "project" ? "project" : "tehsil";
  const hideHeaderSelect = stateParam && districtParam && blockParam;
  const isTehsilMode = typeParam === "tehsil";


  const activeSelectedWaterbody = isTehsilMode
    ? selectedWaterbodyForTehsil
    : selectedWaterbody;

    

  const [view, setView] = useState(
    isTehsilMode ? "map" : typeParam === "tehsil" ? "map" : "table"
  );

  const config = WATER_DASHBOARD_CONFIG[mode];

  useGlobalWaterData({
    type: typeParam,
    projectName: projectNameParam,
    projectId: projectIdParam,
    state: stateParam,
    district: districtParam,
    block: blockParam,
  });

  const handleInfoClick = (anchor, text, key = null) => {
    // anchor must be e.currentTarget (DOM element)
    setInfoAnchor(anchor);
    setInfoText(text);
    setInfoOpen(true);
    setOpenInfoKey(key);
  };

  const handleCloseInfo = () => {
    setInfoAnchor(null);
    setInfoText("");
    setInfoOpen(false);
    setOpenInfoKey(null);
  };

  useEffect(() => {
    const stored = localStorage.getItem("selectedWaterbody");
    if (stored) {
      const parsed = JSON.parse(stored);
      setSelectedWaterbodyForTehsil(parsed);
    }
  }, []);

  useEffect(() => {
    const raw = localStorage.getItem("all_mws_features");
    if (!raw) return;
    const parsed = JSON.parse(raw);
    setMwsFromLocalStorage(parsed);
  }, []);

  console.log(mwsFromLocalStorage)
  const matchedMwsFeature = useMemo(() => {
    if (!selectedWaterbodyForTehsil || !mwsFromLocalStorage?.length) return null;
  
    const mwsUid = selectedWaterbodyForTehsil.properties?.MWS_UID?.toString()?.trim();
    if (!mwsUid) return null;
  
    // Extract first two UID parts → e.g. "12_96671_12_96925" → "12_96671"
    const parts = mwsUid.split("_");
    const partialUid =
      parts.length >= 2 ? `${parts[0]}_${parts[1]}` : mwsUid;
  
    console.log("Searching partial UID:", partialUid);
  
    // 1️⃣ Try exact match first
    let exact = mwsFromLocalStorage.find(f =>
      f.properties?.uid?.toString()?.trim() === mwsUid ||
      f.properties?.MWS_UID?.toString()?.trim() === mwsUid
    );
  
    if (exact) return exact;
  
    // 2️⃣ Fallback: partial match using includes
    let partial = mwsFromLocalStorage.find(f => {
      const uid = f.properties?.uid?.toString()?.trim() || "";
      const mws_uid = f.properties?.MWS_UID?.toString()?.trim() || "";
      return uid.includes(partialUid) || mws_uid.includes(partialUid);
    });
  
    return partial || null;
  
  }, [selectedWaterbodyForTehsil, mwsFromLocalStorage]);
  
  
  
  const matchedMwsOlFeature = useMemo(() => {
    if (!matchedMwsFeature) return null;
  
    return new GeoJSON().readFeature(matchedMwsFeature, {
      dataProjection: "EPSG:4326",
      featureProjection: "EPSG:4326",
    });
  }, [matchedMwsFeature]);
  

  useEffect(() => {
    if (typeParam === "tehsil" && selectedWaterbodyForTehsil?.geometry) {
        
      // 1) create a FeatureCollection with only 1 feature  
      const fc = {
        type: "FeatureCollection",
        features: [selectedWaterbodyForTehsil],
      };

      setTehsilGeoData(fc);

      // 2) Convert to OL Feature
      const featureOL = new GeoJSON().readFeature(
        selectedWaterbodyForTehsil,
        {
          dataProjection: "EPSG:4326",
          featureProjection: "EPSG:4326",
        }
      );

      setTehsilSelectedFeature(featureOL);
    }
  }, [selectedWaterbodyForTehsil, typeParam]);

  useEffect(() => {
    const handleClickOutside = (e) => {
      if (infoAnchor instanceof HTMLElement && !infoAnchor.contains(e.target)) {
        handleCloseInfo();
      }
    };

    window.addEventListener("click", handleClickOutside);
    window.addEventListener("scroll", handleCloseInfo);
    return () => {
      window.removeEventListener("click", handleClickOutside);
      window.removeEventListener("scroll", handleCloseInfo);
    };
  }, [infoAnchor]);

  useEffect(() => {
    const storedOrg = localStorage.getItem("selectedOrganization");
    const storedProject = localStorage.getItem("selectedProject");

    if (storedOrg) {
      const parsedOrg = JSON.parse(storedOrg);

      setOrganization((prev) =>
        prev?.value !== parsedOrg.value ? parsedOrg : prev
      );
    } else {
      setOrganization(null);
    }

    if (storedProject) {
      const parsedProj = JSON.parse(storedProject);
      setProject((prev) =>
        prev?.value !== parsedProj.value ? parsedProj : prev
      );
    } else {
      setProject(null);
    }
  }, [location.key]);

  useEffect(() => {
    if (view === "table") {
      setSelectedWaterbody(null);
      setSelectedFeature(null);
      setMapClickedWaterbody(null);
    }
  }, [view]);

  let tempGeoData =  useRecoilValue(waterGeoDataAtom);
  const geoData = isTehsilMode ? selectedWaterbodyForTehsil : tempGeoData
  const mwsGeoData = useRecoilValue(waterMwsDataAtom);
  const projectZoi = useRecoilValue(zoiFeaturesAtom);
  const tehsilZoi = useRecoilValue(tehsilZoiFeaturesAtom);
  const zoiFeatures = isTehsilMode ? tehsilZoi : projectZoi;
  console.log(zoiFeatures)
  console.log(mwsGeoData)
  console.log(activeSelectedWaterbody)

  const getMatchedMWSFeatureProject = (mwsGeoData, activeSelectedWaterbody) => {
    if (!mwsGeoData?.features?.length || !activeSelectedWaterbody) return null;
  
    // UID from waterbody (project mode)
    const wbMwsUID =
      activeSelectedWaterbody.MWS_UID ||
      activeSelectedWaterbody.properties?.MWS_UID;
  
    if (!wbMwsUID) return null;
  console.log(mwsGeoData)
    // Find feature where UID matches
    const matched = mwsGeoData.features.find(
      (f) =>
        f.properties?.UID?.toString().trim() === wbMwsUID.toString().trim()
    );
  
    return matched || null;
  };

  const matchedMWSFeatureProject = getMatchedMWSFeatureProject(
    mwsGeoData,
    activeSelectedWaterbody
  );
  
  console.log("Matched MWS Feature:", matchedMWSFeatureProject);

  const matchedZoiFeature = useMemo(() => {
    if (!zoiFeatures || !activeSelectedWaterbody) return null;
  
    // In tehsil mode → feature.properties
    const wb = activeSelectedWaterbody.properties || activeSelectedWaterbody;
  
    const wbUID = wb.UID?.toString()?.trim();
    if (!wbUID) return null;
  
    return zoiFeatures.find(f => {
      const zoiUid =
        f.get("UID")?.toString()?.trim() ||
        f.get("uid")?.toString()?.trim();
  
      return zoiUid === wbUID;
    });
  }, [zoiFeatures, activeSelectedWaterbody]);
  
  const zoiAreaFromFeature = matchedZoiFeature
  ? Number(matchedZoiFeature.get("zoi_area")) || 0
  : 0;

  useEffect(() => {
    if (!window.__userSelectedOrgProject && geoData === null) {
      setLoadingData(false);
      return;
    }
      if (geoData?.features) {
      setLoadingData(false);
    } else {
      setLoadingData(true);
    }
  }, [geoData]);
  
  useEffect(() => {
    if (isTehsilMode) return; 
    if (!geoData || !waterbodyParam || autoOpened) return;

    const matchedFeatureIndex = geoData.features.findIndex((f) => {
      const props = f.properties ?? {};
      return (
        props.UID?.toString() === waterbodyParam.toString() ||
        props.uid?.toString() === waterbodyParam.toString() ||
        props.waterbody_uid?.toString() === waterbodyParam.toString()
      );
    });
    

    if (matchedFeatureIndex !== -1) {
      const feature = geoData.features[matchedFeatureIndex];
      const props = feature.properties ?? {};

      const row = {
        featureIndex: matchedFeatureIndex,
        UID: props.UID,
        waterbody: props.waterbody_name ?? props.waterbody ?? "NA",
        waterbody_name: props.waterbody_name ?? props.waterbody ?? "NA",
        MWS_UID:props.MWS_UID || "NA",    
        state: props.State || "NA",
        district: props.District || "NA",
        block: props.Taluka || "NA",
        village: props.village || "NA",

        siltRemoved: Number(props.slit_excavated) || 0,
        areaOred: props.area_ored || 0,
        maxCatchmentArea: props.max_catchment_area || 0,
        maxStreamOrder: props.max_stream_order || 0,
        intervention_year:props.intervention_year || 0,
        coordinates: null,
        geometry: feature.geometry,
      };

      setSelectedWaterbody(row);
      setSelectedFeature(feature);
      setView("map");

      setAutoOpened(true);
    }
  }, [geoData, waterbodyParam, autoOpened]);

  const extractSeasonYears = (props) => {
    const years = new Set();

    Object.keys(props).forEach((key) => {
      const match = key.match(/^(k_|kr_|krz_)(\d{2}[-_]\d{2})$/);
      if (match) {
        let yr = match[2];
        // normalize 17_18 → 17-18
        yr = yr.replace("_", "-");
        years.add(yr);
      }
    });

    return Array.from(years).sort(); // sorted list: ["17-18", "18-19", ...]
  };

  const getFirstNonZeroYearIndex = (props) => {
    const years = extractSeasonYears(props); // dynamic years like ["17-18","18-19",...]

    for (let i = 0; i < years.length; i++) {
      const y = years[i];

      if (
        Number(props[`k_${y}`]) > 0 ||
        Number(props[`kr_${y}`]) > 0 ||
        Number(props[`krz_${y}`]) > 0
      ) {
        return i; // return index of FIRST year that has any non-zero season value
      }
    }

    return -1; // no non-zero data found
  };

  const getPrePostYears = (props, interventionYear) => {
    const years = extractSeasonYears(props);
    if (!years.length) {
      return {
        preYears: [],
        postYears: [],
        startIndex: -1,
        interventionIndex: -1,
      };
    }

    const startIndex = getFirstNonZeroYearIndex(props);
    if (startIndex === -1) {
      return {
        preYears: [],
        postYears: [],
        startIndex: -1,
        interventionIndex: -1,
      };
    }

    // usable years from first non-zero
    const effectiveYears = years.slice(startIndex);

    const interventionIndex = effectiveYears.indexOf(interventionYear);

    // If intervention year missing → all pre
    if (interventionIndex === -1) {
      return {
        preYears: effectiveYears,
        postYears: [],
        startIndex,
        interventionIndex: -1,
      };
    }

    //  FIX: Do not include intervention year in either group
    const preYears = effectiveYears.slice(0, interventionIndex);
    const postYears = effectiveYears.slice(interventionIndex + 1);

    return {
      preYears,
      postYears,
      startIndex,
      interventionIndex,
      allYears: years,
    };
  };

  const computeTotalSeasonAverages = (props) => {
    const years = extractSeasonYears(props); // all seasonal years

    if (!years.length) {
      return {
        avgKharif: "0.00",
        avgRabi: "0.00",
        avgZaid: "0.00",
        totalYears: 0,
        usedYears: [],
      };
    }

    // Use your existing function
    const startIndex = getFirstNonZeroYearIndex(props);

    // If everything is zero
    if (startIndex === -1) {
      return {
        avgKharif: "0.00",
        avgRabi: "0.00",
        avgZaid: "0.00",
        totalYears: 0,
        usedYears: [],
      };
    }

    // Years to use for total season average
    const usedYears = years.slice(startIndex);

    const getAvg = (prefix) => {
      const vals = usedYears.map((y) => Number(props[`${prefix}${y}`]) || 0);
      const sum = vals.reduce((a, b) => a + b, 0);
      const avg = vals.length ? sum / vals.length : 0;
      return avg.toFixed(2);
    };

    return {
      avgKharif: getAvg("k_"),
      avgRabi: getAvg("kr_"),
      avgZaid: getAvg("krz_"),
    };
  };

  const computeAvgSeason = (props, preYears, postYears, prefix) => {
    const avg = (arr) =>
      arr.length
        ? (arr.reduce((a, b) => a + b, 0) / arr.length).toFixed(2)
        : "0.00";

    const beforeValues = preYears.map(
      (y) => Number(props[`${prefix}${y}`]) || 0
    );
    const afterValues = postYears.map(
      (y) => Number(props[`${prefix}${y}`]) || 0
    );

    return {
      before: avg(beforeValues),
      after: avg(afterValues),
    };
  };

  const computeImpact = (before, after) => {
    const b = Number(before);
    const a = Number(after);
    if (isNaN(b) || isNaN(a)) return 0;
    return Number((a - b).toFixed(2));
  };

  const getImpactColor = (impact) => (impact >= 0 ? "green" : "red");

  // Impacted Area for ONE waterbody — Rabi
  const computeImpactedAreaRabi = (areaOred, impactRabi) => {
    const area = Number(areaOred) || 0;
    const impact = Number(impactRabi) || 0;
    return Number((area * impact).toFixed(2));
  };

  // Impacted Area for ONE waterbody — Zaid
  const computeImpactedAreaZaid = (areaOred, impactZaid) => {
    const area = Number(areaOred) || 0;
    const impact = Number(impactZaid) || 0;
    return Number((area * impact).toFixed(2));
  };

  // Sum Area-ored of all rows
  const computeTotalAreaOred = (rows) => {
    return rows.reduce((sum, r) => sum + (Number(r.areaOred) || 0), 0);
  };

  // Sum of all impacted areas for rabi
  const computeTotalRabiImpactedArea = (rows) => {
    return rows.reduce((sum, r) => sum + (Number(r.rabiImpactedArea) || 0), 0);
  };

  // Sum of all impacted areas for zaid
  const computeTotalZaidImpactedArea = (rows) => {
    return rows.reduce((sum, r) => sum + (Number(r.zaidImpactedArea) || 0), 0);
  };

  const computeDoubleTripleAvg = (matchedZoi) => {
    if (!matchedZoi) return { avgDouble: "0.00", avgTriple: "0.00" };

    const doubleVals = [];
    const tripleVals = [];

    matchedZoi.getKeys().forEach((key) => {
      const match = key.match(
        /(doubly_cropped_area_|triply_cropped_area_)(\d{4})/
      );
      if (match) {
        const year = match[2];
        const value = Number(matchedZoi.get(key)) || 0;

        if (match[1] === "doubly_cropped_area_") doubleVals.push(value);
        if (match[1] === "triply_cropped_area_") tripleVals.push(value);
      }
    });

    const avg = (arr) =>
      arr.length ? arr.reduce((a, b) => a + b, 0) / arr.length / 10000 : 0;

    return {
      avgDouble: avg(doubleVals).toFixed(2),
      avgTriple: avg(tripleVals).toFixed(2),
    };
  };

  const getCoordinatesFromGeometry = (geometry) => {
    if (!geometry) return null;

    const { type, coordinates } = geometry;

    switch (type) {
      case "Point":
        return coordinates;

      case "Polygon":
        if (!coordinates?.[0]?.length) return null;
        const ring = coordinates[0];
        const sumX = ring.reduce((acc, coord) => acc + coord[0], 0);
        const sumY = ring.reduce((acc, coord) => acc + coord[1], 0);
        return [sumX / ring.length, sumY / ring.length];

      case "LineString":
        if (!coordinates?.length) return null;
        const middleIndex = Math.floor(coordinates.length / 2);
        return coordinates[middleIndex];

      default:
        return null;
    }
  };

  const {
    rows,
    totalSiltRemoved,
    projectLevelRabiImpact,
    projectLevelZaidImpact,
  } = useMemo(() => {
    if (!geoData?.features) {
      return {
        rows: [],
        totalSiltRemoved: 0,
        totalRabiImpactedArea: 0,
        totalZaidImpactedArea: 0,
        projectLevelRabiImpact: 0,
        projectLevelZaidImpact: 0,
      };
    }
    let totalSiltRemoved = 0;
    const mappedRows = geoData.features.map((feature, index) => {
      const props = feature.properties ?? {};

      const { preYears, postYears } = getPrePostYears(props, props.intervention_year);
      const { avgRabi, avgZaid } = computeTotalSeasonAverages(props);

      const rabi = computeAvgSeason(props, preYears, postYears, "kr_");
      const zaid = computeAvgSeason(props, preYears, postYears, "krz_");

      const ImpactRabi = computeImpact(rabi.before, rabi.after);
      const ImpactZaid = computeImpact(zaid.before, zaid.after);

      const rabiImpactedArea = computeImpactedAreaRabi(
        props.area_ored,
        ImpactRabi
      );
      const zaidImpactedArea = computeImpactedAreaZaid(
        props.area_ored,
        ImpactZaid
      );

      const { avgDouble, avgTriple } = computeDoubleTripleAvg(
        zoiFeatures.find(
          (f) =>
            f.get("UID")?.toString().trim() === props?.UID?.toString().trim()
        )
      );

      const coordinates = getCoordinatesFromGeometry(feature.geometry);
      totalSiltRemoved += Number(props.slit_excavated) || 0;

      return {
        id: index + 1,
        state: props.State || "NA",
        district: props.District || "NA",
        block: props.Taluka || "NA",
        village: props.village || "NA",
        waterbody: props.waterbody_name || "NA",
        UID: props.UID || "NA",
        areaOred: props.area_ored || 0,
        interventionYear: props.intervention_year ?? "—",
        maxCatchmentArea: props.max_catchment_area || 0,
        maxStreamOrder: props.max_stream_order || 0,
        MWS_UID: props.MWS_UID || 0,
        drainageFlag: props.on_drainage_line ?? props.drainage ?? 0,


        siltRemoved: Number(props.slit_excavated) || 0,

        avgWaterAvailabilityRabi: avgRabi,
        avgWaterAvailabilityZaid: avgZaid,

        ImpactRabi,
        ImpactRabiColor: getImpactColor(ImpactRabi),
        ImpactZaid,
        ImpactZaidColor: getImpactColor(ImpactZaid),

        rabiImpactedArea,
        zaidImpactedArea,

        avgDoubleCropped: avgDouble,
        avgTripleCropped: avgTriple,

        coordinates,
        featureIndex: index,
      };
    });

    // TOTALS
    const totalAreaOred = computeTotalAreaOred(mappedRows);
    const totalRabiImpactedArea = computeTotalRabiImpactedArea(mappedRows);
    const totalZaidImpactedArea = computeTotalZaidImpactedArea(mappedRows);

    return {
      rows: mappedRows,
      totalSiltRemoved,
      totalAreaOred,
      totalRabiImpactedArea,
      totalZaidImpactedArea,

      projectLevelRabiImpact: totalAreaOred
        ? totalRabiImpactedArea / totalAreaOred
        : 0,

      projectLevelZaidImpact: totalAreaOred
        ? totalZaidImpactedArea / totalAreaOred
        : 0,
    };
  }, [geoData, zoiFeatures]);

  const totalRows = rows.length;
  
  
  const handleFilterClick = (event, type) => {
    setAnchorEl(event.currentTarget);
    setFilterType(type);
    setSearchText("");
  };

  const handleViewChange = (event, newView) => {
    if (isTehsilMode) return;
    if (newView !== "table" && newView !== "map") return;
    setView(newView);
    if (newView === "table") {
      const params = new URLSearchParams(location.search);
      params.delete("waterbody");
      navigate(`/dashboard?${params.toString()}`, { replace: true });
    }
  };

  const handleSort = (field) => {
    if (sortField === field) {
      setSortOrder((prevOrder) => (prevOrder === "asc" ? "desc" : "asc"));
    } else {
      setSortField(field);
      setSortOrder("asc");
    }
  };

  const filteredRows = rows.filter((row) => {
    const matchesGlobalSearch = Object.keys(row).some((key) => {
      if (!row[key]) return false;
      if (typeof row[key] === "object") return false; // skip objects like coordinates
      return row[key]
        .toString()
        .toLowerCase()
        .includes(searchText.toLowerCase());
    });

    const matchesFilters = Object.keys(filters).every((key) => {
      if (filters[key].length === 0) return true;
      return filters[key].includes(String(row[key]));
    });

    const matchesWaterbodySearch = row.waterbody
      ?.toString()
      .toLowerCase()
      .includes(waterbodySearch.toLowerCase());

    return matchesGlobalSearch && matchesFilters && matchesWaterbodySearch;
  });

  const sortedRows = [...filteredRows].sort((a, b) => {
    if (!sortField) return 0;
    const aValue = a[sortField];
    const bValue = b[sortField];

    if (sortField === "avgWaterAvailabilityZaid") {
      const aNumeric = parseFloat(aValue.replace("%", ""));
      const bNumeric = parseFloat(bValue.replace("%", ""));
      return sortOrder === "asc" ? aNumeric - bNumeric : bNumeric - aNumeric;
    }

    if (!isNaN(parseFloat(aValue)) && !isNaN(parseFloat(bValue))) {
      return sortOrder === "asc"
        ? parseFloat(aValue) - parseFloat(bValue)
        : parseFloat(bValue) - parseFloat(aValue);
    }

    return sortOrder === "asc"
      ? String(aValue).localeCompare(String(bValue))
      : String(bValue).localeCompare(String(aValue));
  });

  const handleWaterbodyClick = (row) => {
    const params = new URLSearchParams(location.search);

    const type = params.get("type");
    const projectName = params.get("project_name");
    const state = params.get("state");
    const district = params.get("district");
    const block = params.get("block");

    // Build URL
    let url = "/dashboard?";

    if (type === "project") {
      url += `type=project&project_name=${encodeURIComponent(
        projectName
      )}&waterbody=${row.UID}`;
    } else {
      url += `type=tehsil&state=${encodeURIComponent(
        state
      )}&district=${encodeURIComponent(district)}&block=${encodeURIComponent(
        block
      )}&waterbody=${row.UID}`;
    }

    navigate(url);
    const feature = geoData.features.find((f, idx) => idx === row.featureIndex);

    if (feature) {
      const mwsId = feature.properties?.MWS_UID;

      if (feature.geometry?.type === "MultiPolygon") {
        row.coordinates = null;
      } else if (
        feature.properties?.latitude &&
        feature.properties?.longitude
      ) {
        row.coordinates = [
          feature.properties.longitude,
          feature.properties.latitude,
        ];
      }

      const matchingMWSFeature = mwsGeoData?.features?.find((f) =>
        mwsId?.includes(f.properties?.uid)
      );
      if (matchingMWSFeature) setSelectedMWSFeature(matchingMWSFeature);

      setSelectedWaterbody(row);
      setSelectedFeature(feature);
      setView("map");
      window.scrollTo({ top: 0, behavior: "smooth" });
    }
  };

  const handleMapBoxClick = () => {
    if (!mapClickedWaterbody?.UID) {
      console.warn("Popup has no UID");
      return;
    }
  
    const uid = mapClickedWaterbody.UID.toString().trim();
  
    // Find row by UID
    const matchingRow = rows.find(
      (row) => row.UID?.toString().trim() === uid
    );
  
    if (matchingRow) {
      handleWaterbodyClick(matchingRow);
    } else {
      console.warn("No matching row found for UID:", uid);
    }
  };
  

  const printReport=()=>{
    window.print();
  }
  const capitalize = (str) => str ? str.charAt(0).toUpperCase() + str.slice(1).toLowerCase() : "";
  
  return (
    <div className="relative w-full ">
      {isTehsilMode && (
  <div className="relative w-full left-1/2 right-1/2 -ml-[50vw] -mr-[50vw]">
    <div
      className="w-full shadow-md"
      style={{
        backgroundColor: "#2c3e50",
        margin: 0,
        paddingTop: "48px",
        paddingBottom: "48px",        
        width: "100vw",
        position: "relative",
        left: "50%",
        right: "50%",
        marginLeft: "-50vw",
        marginRight: "-50vw",
      }}
    >
      <button
        className="absolute top-4 right-6 flex items-center gap-2
                   bg-green-600 hover:bg-green-700 text-white font-semibold 
                   px-4 py-2 rounded-md shadow-md transition-all"
                   onClick={printReport}
      >
        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18"
             viewBox="0 0 24 24" fill="none" stroke="currentColor"
             strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <polyline points="6 9 6 2 18 2 18 9"></polyline>
            <path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path>
            <rect x="6" y="14" width="12" height="8"></rect>
        </svg>
        Save as PDF
      </button>
      <h1 className="text-2xl md:text-3xl font-bold text-center text-white">
        Waterbody Data Analysis Report
      </h1>
      <p className="text-sm md:text-base text-blue-100 text-center mt-1">
        {`Tehsil: ${activeSelectedWaterbody?.properties?.Taluka || blockParam || "NA"}`}
        {activeSelectedWaterbody?.properties?.UID ? ` • UID: ${activeSelectedWaterbody.properties.UID}` : ""}
      </p>
    </div>
  </div>
)}

      {!hideHeaderSelect && (
          <HeaderSelect showExtras organization={organization} project={project} setView={setView}/>
      )} 
      {!isTehsilMode && (     
      <div className={`absolute left-6 z-50 flex flex-col items-start font-bold
        ${typeParam === "tehsil" ? "top-4" : "top-32"}`}>

        {/* Toggle Button Group */}
        <div className="flex items-center justify-between gap-2 w-[240px] sm:w-[260px] md:w-[280px]px-2 py-1 rounded-md border-2 border-black bg-white/40 backdrop-blur-md shadow-md">
          {/* Table Button */}
          <button type="button" onClick={() => handleViewChange(null, "table")} className={`flex items-center justify-center gap-2 flex-1 font-semibold text-black py-2 rounded transition-all duration-150 ease-in-out
          ${view === "table" ? "bg-white/70 shadow-inner scale-[0.99]" : "hover:bg-white/50 active:scale-[0.98]"}`}>
            <span className="text-sm sm:text-base">Table</span>
            <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 0 24 24" fill="currentColor">
              <path d="M3 3h18v18H3V3zm2 2v4h4V5H5zm6 0v4h4V5h-4zm6 0v4h4V5h-4zM5 11v4h4v-4H5zm6 0v4h4v-4h-4zm6 0v4h4v-4h-4zM5 17v2h4v-2H5zm6 0v2h4v-2h-4zm6 0v2h4v-2h-4z" />
            </svg>
          </button>

          {/* Map Button */}
          <button type="button" onClick={() => handleViewChange(null, "map")} className={`flex items-center justify-center gap-2 flex-1 font-semibold text-black py-2 rounded transition-all duration-150 ease-in-out 
          ${view === "map" ? "bg-white/70 shadow-inner scale-[0.99]" : "hover:bg-white/50 active:scale-[0.98]"}`}>
            <span className="text-sm sm:text-base">Map</span>
            <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 0 512 512" fill="currentColor">
              <path d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm82.4 368.2-17.6 17.6h-64l-32-32v-32h-32l-48-48 16-48 32-16v-32l32-32h32l16 16 32-32-16-48h-32l-48 16-16-16v-48l64-16 80 
          32v48l16 16 48-16 16 16v80l-32 48h-32v32l16 48-32 32z"/>
            </svg>
          </button>
        </div>
      </div>
      )}

      {/* Conditional Rendering for Table or Map */}
      <div
          className={`
            absolute top-[calc(20%+72px)]
            md:top-[calc(18%+64px)]
            sm:top-[calc(16%+48px)]
            left-[2.5%] w-[92%] h-auto z-[1]
            ${project && geoData?.features?.length > 0 ? "bg-white p-5 rounded-md" : "bg-transparent p-0"}
          `}
>
        {!isTehsilMode && view === "table" ? (
          loadingData ? (
            <div className="flex justify-center items-center h-40">
              <div className="animate-spin rounded-full h-12 w-12 border-4 border-gray-300 border-t-blue-600"></div>
            </div>
          ) : (
            <>
            {(project && geoData?.features?.length > 0) ? (
              <>
                <TopSection
                  configTextFn={config.topSectionText}
                  data={{
                    projectName: project?.label,
                    tehsilName: mode === "tehsil" ? capitalize(blockParam) : null,
                    totalRows,
                    totalSiltRemoved,
                    rabiImpact: projectLevelRabiImpact,
                    zaidImpact: projectLevelZaidImpact,
                    interventionYear: rows?.[0]?.interventionYear || "NA",
                  }}
                />
          
                <TableView
                  headers={config.tableHeaders}
                  rows={sortedRows}
                  sortField={sortField}
                  sortOrder={sortOrder}
                  waterbodySearch={waterbodySearch}
                  onSort={handleSort}
                  onFilterClick={handleFilterClick}
                  onInfoClick={handleInfoClick}
                  onSearchChange={(value) => setWaterbodySearch(value)}
                  onRowClick={handleWaterbodyClick}
                />
              </>
            ) : (
              <div className="fixed top-[160px] left-0 w-full px-6 mt-12">
  <div className="w-full py-6 bg-white border border-gray-300 rounded-md shadow text-center text-gray-700 font-semibold text-lg">
    Please select Organization & Project to view data.
  </div>
</div>

            
            )}
          </>
          
          )
        ) : view === "map" ? (
          <div >

          <div  className={`flex flex-col gap-4 w-full px-2 sm:px-4 md:px-6 ${isTehsilMode ? "mt-28" : "mt-2"}`}>
            {activeSelectedWaterbody && (
              <div className="flex flex-col gap-2 w-full p-4 sm:p-6 md:p-4 rounded-xl bg-white shadow-md">
                {/* Heading */}
                <h2 className="text-lg sm:text-lg md:text-xl font-bold text-blue-600 border-b-2 border-blue-600 pb-1">
                  {WATER_DASHBOARD_CONFIG.sections.section1.title}{" "}
                </h2>
                {WATER_DASHBOARD_CONFIG.sections.section1.paragraphs.map(
                  (t, i) => ( <p key={i}>{t}</p>)
                )}
              </div>
            )}

            <div className="flex flex-col md:flex-row items-start gap-4 w-full">
              <div className={`relative ${activeSelectedWaterbody ? "w-full md:w-[65%]" : "w-full"}`}>
                {!activeSelectedWaterbody &&  typeParam !== "tehsil" && (
                  <div className="absolute top-0 left-0 right-0 bg-white/90 text-center  py-1 border-b border-gray-300    font-semibold text-[16px] z-[1200] flex items-center justify-center gap-2">
                    {WATER_DASHBOARD_CONFIG.labels.clickToView}
                    <img src="https://cdn-icons-png.flaticon.com/512/684/684908.png" alt="marke" className="w-5 h-5 mx-1"/>
                  </div>
                )}

                 <DashboardBasemap id="map1" 
                type={typeParam}
                district={districtParam}
                block={blockParam}
                mode="waterbody"
                geoData={typeParam === "tehsil" ? tehsilGeoData : geoData}
                selectedWaterbody={activeSelectedWaterbody}
                  lulcYear={lulcYear1} 
                projectName={typeParam === "project" ? project?.label : null}
                projectId={typeParam === "project" ? project?.value : null}
                onSelectWaterbody={(data) => {
                    const name = data.name ?? data.waterbody_name ?? data.waterbody ??
                      (data.properties && (data.properties.waterbody_name || data.properties.name)) ?? "";
                    setMapClickedWaterbody({
                      name,
                      waterbody: name, 
                      Village: data.Village ?? data.village ?? "",
                      Taluka: data.Taluka ?? data.Taluka ?? "",
                      UID: data.UID ?? data.uid ?? "",
                      MWS_ID: data.MWS_ID,
                      pixel: data.pixel ?? null,
                      siltRemoved: data.siltRemoved ?? data.slit_excavated ?? null,
                      areaOred: data.areaOred ?? data.area_ored ?? null,
                    });
                  }}
                />

                {/* Top-left Label */}
                {activeSelectedWaterbody && (
                <div className="absolute top-4 left-4 bg-white/90 p-2 sm:p-3 rounded-md font-bold shadow flex flex-col items-start gap-1 z-[1000] max-w-[90%] sm:max-w-[300px]">
                  {(() => {const props = activeSelectedWaterbody.properties || activeSelectedWaterbody;
                  return (
                    <>
                      <div className="flex items-center gap-1">
                        <LocationOnIcon className="text-blue-600" fontSize="small" />

                        {/* Waterbody Name */}
                        {/* {props.waterbody_name &&
                          props.waterbody_name.trim().toUpperCase() !== "NA" &&
                          props.waterbody_name.trim() !== "" && (
                            <p className="font-semibold text-gray-900">
                              {props.waterbody_name}
                            </p>
                          )
                        } */}

                        {/* UID */}
                        <p className="font-semibold text-gray-900">
                          {props.UID || "UID"}
                        </p>
                      </div>

                      {/* Silt removed */}
                      {Number(props.siltRemoved || props.slit_excavated) > 0 && (
                        <p className="text-gray-700 text-sm font-semibold">
                          Silt Removed: {props.siltRemoved || props.slit_excavated} cubic metres
                        </p>
                      )}

                      {/* Area ORED */}
                      <p className="text-gray-700 text-sm font-semibold">
                        Area (in hectares): {(props.areaOred || props.area_ored || 0).toFixed(2)} hectares
                      </p>
                    </>
                  );
                  })()}
                </div>
                )}

                {/* Legend + YearSlider wrapper for responsiveness */}
                {activeSelectedWaterbody && (
                  <div
                    className="absolute bottom-4 left-4 right-4 flex flex-col sm:flex-row justify-between gap-2 flex-wrap z-[1000]"
                  >
                    {/* Collapsible Legend for Map 1 */}
                    {!waterbodyLegend ? (
                      <div onClick={() => setWaterbodyLegend(true)} className="bg-white/90 px-1.5 py-1.5 rounded-r-md shadow-md cursor-pointer font-bold text-[13px] select-none hover:bg-white transition"
                        style={{
                          writingMode: "vertical-rl",
                          textOrientation: "mixed",
                          borderTopLeftRadius: 0,
                          borderBottomLeftRadius: 0,
                        }}
                      >
                        Water Layer Legend ▶
                      </div>
                    ) : (
                      <div
                        className="bg-white/90 p-4 rounded-md shadow-md flex-[1_1_180px] min-w-[260px] max-w-[200px]"
                      >
                        {/* Header row */}
                        <div className="flex justify-between items-center">
                          <p className="text-sm font-semibold">
                            Water Layer Legend
                          </p>
                          <button
                            onClick={() => setWaterbodyLegend(false)}
                            className="border-none bg-transparent cursor-pointer text-lg hover:opacity-75"
                          >
                            ◀
                          </button>
                        </div>

                        {/* Legend items from config */}
                        {WATER_DASHBOARD_CONFIG.legends.waterbody.map(
                          (item, idx) => (
                            <div key={idx} className="flex items-center gap-2 mt-2">
                              <div className="w-5 h-5 border border-black opacity-70" style={{ backgroundColor: item.color }}></div>
                              <p className="text-sm">{item.label}</p>
                            </div>
                          )
                        )}
                      </div>
                    )}

                    {/* YearSlider stays untouched */}
                    <div
                      className="bg-white/90 p-4 rounded-md shadow-md flex-shrink-0 flex-grow-0 min-w-[220px] sm:min-w-[300px] md:min-w-[500px]"
                    >
                      <YearSlider
                        currentLayer={{ name: "lulcWaterrej" }}
                        sliderId="map1"
                      />
                    </div>
                  </div>
                )}
              </div>
              {mapClickedWaterbody && !activeSelectedWaterbody && (
                <div
                  onClick={handleMapBoxClick}
                  className="absolute z-[9999] w-[250px] p-2 bg-white rounded-md border border-gray-300 
                      flex flex-col gap-1 cursor-pointer shadow-md transition-all duration-200 
                      hover:shadow-xl hover:-translate-y-0.5 hover:border-[#1976d2]"
                  style={{
                    top: `${mapClickedWaterbody.pixel[1]}px`,
                    left: `${mapClickedWaterbody.pixel[0] + 15}px`,
                    transform: "translate(-50%, -100%)",
                  }}
                >
                  <p className="text-[#1976d2] font-bold border-b border-gray-200 pb-1 text-base">
                    {mapClickedWaterbody.name}
                  </p>

                  <div className="flex justify-between text-sm">
                    <p className="font-semibold text-gray-600">Village:</p>
                    <p className="font-medium text-gray-900">
                      {mapClickedWaterbody.Village ?? "NA"}
                    </p>
                  </div>

                  <div className="flex justify-between text-sm">
                    <p className="font-semibold text-gray-600">Taluka:</p>
                    <p className="font-medium text-gray-900">
                      {mapClickedWaterbody.Taluka ?? "NA"}
                    </p>
                  </div>

                  <p className="mt-1 text-[#1976d2] font-semibold text-right text-sm cursor-pointer hover:underline">
                    View details →
                  </p>
                </div>
              )}

              {/* Charts Section */}
              {activeSelectedWaterbody && (
                <div className="w-full md:w-[45%] flex flex-col items-center gap-6 sm:gap-8 md:gap-10 lg:gap-12">
                  <div className="w-full max-w-[700px] h-[200px] sm:h-[350px] md:h-[300px] mx-auto">
                    <WaterAvailabilityChart
                      isTehsil={isTehsilMode}
                      waterbody={isTehsilMode ? activeSelectedWaterbody.properties.UID : activeSelectedWaterbody}
                      water_rej_data={isTehsilMode ? {features : [geoData]} : geoData}
                      mwsFeature={isTehsilMode ? matchedMwsOlFeature : mwsGeoData}
                      onImpactYearChange={(yearData) => setImpactYear(yearData)}
                    />
                  </div>

                  {(isTehsilMode ? mwsFromLocalStorage : selectedMWSFeature) && (
                  <div className="w-full max-w-[700px] h-[200px] sm:h-[350px] md:h-[290px] mt-36 mx-auto">
                    <PrecipitationStackChart feature={typeParam === "tehsil" ? matchedMwsOlFeature : mwsGeoData}
                     waterbody={activeSelectedWaterbody} typeparam={typeParam}/>
                  </div>
                  )}
                </div>
              )}
            </div>

            {/* ZOI Section with Map + Side Chart */}
            {activeSelectedWaterbody && (
              <div className="flex flex-col gap-2 w-full p-2 sm:p-3 md:p-2 rounded-xl bg-white shadow-sm">
                {/* Heading */}
                <h2 className="text-lg sm:text-lg md:text-xl font-bold text-blue-600 border-b-2 border-blue-600 pb-1">
                  {WATER_DASHBOARD_CONFIG.sections.section2.title}{" "}
                </h2>

                {/* Explanation */}
                {WATER_DASHBOARD_CONFIG.sections.section2.paragraphs.map(
                  (p, i) => (
                    <p key={i} className="text-gray-600 leading-relaxed">
                      {p}
                    </p>
                  )
                )}
              </div>
            )}
            {activeSelectedWaterbody && (
              <>
                <div className="flex flex-col md:flex-row items-start gap-4 w-full mt-6">
                  <div className="relative w-full md:w-[65%]">
                    <DashboardBasemap
                      id="map2"
                      mode="zoi"
                      geoData={typeParam === "tehsil" ? tehsilGeoData : geoData}
                      zoiFeatures={zoiFeatures}
                      selectedWaterbody={activeSelectedWaterbody}
                      lulcYear={lulcYear2}
                      projectName={typeParam === "project" ? project?.label : null}
                      projectId={typeParam === "project" ? project?.value : null}
                      onZoiArea={setZoiArea}
                      district={districtParam}
                      block={blockParam}
                      type={typeParam}
                    />

      <div className="absolute top-4 left-4 bg-white/90 px-3 py-2 rounded-md font-bold shadow-sm flex flex-col items-start gap-1 z-[1000] max-w-[90%] sm:max-w-[300px]">
        {(() => {
          const props = activeSelectedWaterbody.properties || activeSelectedWaterbody;

          return (
            <>
              <div className="flex items-center gap-1">
                <LocationOnIcon className="text-blue-600 w-4 h-4" />

                {/* Waterbody Name */}
                {/* {props.waterbody_name &&
          props.waterbody_name.trim() !== "" &&
          props.waterbody_name.trim().toUpperCase() !== "NA" && (
            <p className="font-semibold text-gray-900">
              {props.waterbody_name}
            </p>
          )} */}

                {/* UID */}
                <p className="font-semibold text-gray-900">
                  {props.UID || "UID"}
                </p>
              </div>

              {/* ZOI Area */}
              <p className="text-sm text-gray-700 font-extrabold">
                ZOI Area:{" "}
                {zoiAreaFromFeature > 0
                  ? `${zoiAreaFromFeature.toFixed(2)} hectares`
                  : "NA"}
              </p>
            </>
          );
        })()}
      </div>

                    {/* Legend + YearSlider wrapper */}
                    <div className="absolute bottom-4 left-4 right-4 flex flex-col sm:flex-row justify-between gap-2 flex-wrap z-[1000]">
                      {/* ZOI Legend (collapsible) */}
                      {!zoiLegend ? (
                        <div
                          onClick={() => setZoiLegend(true)}
                          className="bg-white/90 px-1.5 py-1.5 rounded-r-md shadow-md cursor-pointer font-bold text-[13px] select-none hover:bg-white transition"
                          style={{
                            writingMode: "vertical-rl",
                            textOrientation: "mixed",
                            borderTopLeftRadius: 0,
                            borderBottomLeftRadius: 0,
                          }}
                        >
                          Zoi Legend ▶
                        </div>
                      ) : (
                        <div className="bg-white/90 p-4 rounded-md shadow-md flex-[1_1_180px] min-w-[260px] max-w-[200px]">
                          {/* Header */}
                          <div className="flex justify-between items-center">
                            <p className="text-sm font-semibold">Zoi Legend</p>
                            <button
                              onClick={() => setZoiLegend(false)}
                              className="border-none bg-transparent cursor-pointer text-lg hover:opacity-75"
                            >
                              ◀
                            </button>
                          </div>

                          {/* Legend items from CONFIG */}
                          {WATER_DASHBOARD_CONFIG.legends.zoi.map(
                            (item, idx) => (
                              <div
                                key={idx}
                                className="flex items-center gap-2 mt-2"
                              >
                                <div
                                  className="w-5 h-5 border border-black opacity-70"
                                  style={{ backgroundColor: item.color }}
                                ></div>
                                <p className="text-sm">{item.label}</p>
                              </div>
                            )
                          )}
                        </div>
                      )}

                      {/* YearSlider (unchanged) */}
                      <div className="bg-white/90 p-4 rounded-md shadow-md flex-shrink-0 flex-grow-0 min-w-[220px] sm:min-w-[300px] md:min-w-[500px]">
                        <YearSlider
                          currentLayer={{ name: "lulcWaterrej" }}
                          sliderId="map2"
                        />
                      </div>
                    </div>
                  </div>

                  <div className="w-full md:w-[45%] flex flex-col items-center">
                    <div className="w-full max-w-[700px] h-[300px] sm:h-[350px] md:h-[400px]">
                      <CroppingIntensityStackChart
                        zoiFeatures={zoiFeatures}
                        waterbody={activeSelectedWaterbody}
                        impactYear={impactYear}
                        isTehsil={isTehsilMode}
                      />
                    </div>

                    <div className="w-full max-w-[700px] h-[300px] sm:h-[350px] md:h-[400px] mt-10">
                      <DroughtChart
                      mwsGeoData={isTehsilMode ? tehsilDrought : mwsGeoData}
                        waterbody={activeSelectedWaterbody}
                        typeparam={typeParam}
                      />
                      {/* <NDMIPointChart
                          zoiFeatures={zoiFeatures}
                          waterbody={selectedWaterbody}
                        /> */}
                    </div>
                  </div>
                </div>

                <div className="w-full flex flex-col md:flex-row gap-4 md:gap-6 items-stretch md:items-end">
                  {/* NDVI Chart (Left Side) */}
                  <div className="w-full h-[300px] sm:h-[350px] md:h-[400px]">
                    <NDVIChart
                      zoiFeatures={zoiFeatures}
                      waterbody={activeSelectedWaterbody}
                      years={WATER_DASHBOARD_CONFIG.ndviYears}
                    />
                  </div>
                </div>
              </>
            )}
            {/*MWS map section */}
            {activeSelectedWaterbody && (
              <div className="flex flex-col gap-2 w-full p-2 sm:p-3 md:p-4 rounded-lg bg-white shadow-sm">
                {/* Heading */}
                <h2 className="text-lg sm:text-lg md:text-xl font-bold text-blue-600 border-b-2 border-blue-600 pb-1">
                  {WATER_DASHBOARD_CONFIG.sections.section3.title}{" "}
                </h2>
                {WATER_DASHBOARD_CONFIG.sections.section3.paragraphs.map(
                  (p, i) => (
                    <p key={i} className="text-gray-600 leading-relaxed">
                      {p}
                    </p>
                  )
                )}
              </div>
            )}
{activeSelectedWaterbody && (
  <div className="w-full mt-4 px-2 md:px-0">

    {/* Always show Max Catchment Area */}
    <div className="w-full flex flex-col md:flex-row justify-between gap-3">
      <div
        className="flex-1 bg-gradient-to-br from-gray-50 to-gray-100 p-4 md:p-6 rounded-xl 
        border border-gray-200 shadow-sm flex flex-col items-center text-center min-h-[120px] 
        transition-all duration-300 hover:-translate-y-0.5 hover:shadow-md"
      >
        <p className="uppercase tracking-wide font-bold text-sm text-gray-800">
          Max Catchment Area
        </p>
        <p className="mt-1 text-xl md:text-2xl font-semibold text-blue-600">
          {(() => {
            const props = activeSelectedWaterbody.properties || {};
            const value = isTehsilMode
              ? props.max_catchment_area
              : activeSelectedWaterbody.maxCatchmentArea;

            return value ? `${Number(value).toFixed(2)} sq km` : "N/A";
          })()}
        </p>
 
      </div>
      <div
  className="flex-1 bg-gradient-to-br from-gray-50 to-gray-100 p-4 md:p-6 rounded-xl 
  border border-gray-200 shadow-sm flex flex-col items-center text-center min-h-[120px] 
  transition-all duration-300 hover:-translate-y-0.5 hover:shadow-md"
>
  <p className="uppercase tracking-wide font-bold text-sm text-gray-800">
    On Drainage Line
  </p>

  {(() => {
    const props = activeSelectedWaterbody?.properties || {};

    // ⭐ Drainage flag based on mode
    const drainageFlag = isTehsilMode
      ? props.on_drainage_line ?? props.drainage
      : activeSelectedWaterbody?.drainageFlag;

    // ⭐ Stream order based on mode
    const streamOrder = isTehsilMode
      ? props.max_stream_order
      : activeSelectedWaterbody?.maxStreamOrder;

    // ⭐ If NOT on drainage line
    if (drainageFlag !== 1) {
      return (
        <p className="mt-1 text-xl md:text-2xl font-semibold text-red-500">
          Not On Drainage Line
        </p>
      );
    }

    // ⭐ If ON drainage line → show stream order
    return (
      <p className="mt-1 text-xl md:text-2xl font-semibold text-blue-600">
        {streamOrder ? `ON (Order ${streamOrder})` : "N/A"}
      </p>
    );
  })()}
</div>



      {/* Max Stream Order → Only visible if on drainage line */}
        <div
          className="flex-1 bg-gradient-to-br from-gray-50 to-gray-100 p-4 md:p-6 rounded-xl 
          border border-gray-200 shadow-sm flex flex-col items-center text-center min-h-[120px] 
          transition-all duration-300 hover:-translate-y-0.5 hover:shadow-md"
        >
          <p className="uppercase tracking-wide font-bold text-sm text-gray-800">
           Watershed position
          </p>
          <p className="mt-1 text-xl md:text-2xl font-semibold text-blue-600">
  {(() => {
    const props = activeSelectedWaterbody?.properties || {};

    const streamOrder = isTehsilMode
      ? props.max_stream_order
      : activeSelectedWaterbody?.maxStreamOrder;

    return streamOrder
      ? `Order ${streamOrder}`
      : "N/A";
  })()}
</p>


        </div>
      
    </div>

  </div>
)}



            <div className="flex flex-col md:flex-row items-start gap-4 w-full">
              {/* Map 3 */}
              {activeSelectedWaterbody && (
                <div className="relative w-full h-[85vh]">
                  {/* MAP */}
                  <DashboardBasemap
                    id="map3"
                    mode="mws"
                    geoData={typeParam === "tehsil" ? tehsilGeoData : geoData}
                    mwsData={typeParam === "tehsil" ? matchedMwsOlFeature : mwsGeoData}

                    // mwsData={mwsGeoData}
                    selectedWaterbody={activeSelectedWaterbody}
                    selectedFeature={typeParam === "tehsil" ? mwsFromLocalStorage : selectedFeature}
                    lulcYear={lulcYear2} 
                    projectName={typeParam === "project" ? project?.label : null}
                    projectId={typeParam === "project" ? project?.value : null}
                    organizationLabel={organization?.label}
                    onZoiArea={setZoiArea}
                    district={districtParam}
                    block={blockParam}
                    type={typeParam}
                  />

                  {/* Overlay container */}
                  <div className="absolute inset-0 z-20 pointer-events-none">
                    {/* Terrain Legend — Bottom Left */}
                    <div className="absolute left-0 bottom-0 p-4 pointer-events-auto">
                      {!terrainLegend ? (
                        <div
                          onClick={() => setTerrainLegend(true)}
                          className="bg-white/90 px-2 py-1 rounded-r-md shadow-md cursor-pointer font-bold text-gray-800 hover:bg-white transition-colors duration-150"
                          style={{
                            writingMode: "vertical-rl",
                            textOrientation: "mixed",
                          }}
                        >
                          Terrain Legend ▶
                        </div>
                      ) : (
                        <div className="bg-white/90 p-4 rounded-md shadow-md w-full max-w-xs min-w-[220px] pointer-events-auto">
                          <div className="flex justify-between items-center mb-2">
                            <p className="text-sm font-semibold">
                              Terrain Layer Legend
                            </p>
                            <button
                              onClick={() => setTerrainLegend(false)}
                              className="text-gray-700 hover:text-black transition-colors duration-150 cursor-pointer"
                            >
                              ◀
                            </button>
                          </div>

                          {WATER_DASHBOARD_CONFIG.legends.terrain.map(
                            (item, idx) => (
                              <div
                                key={idx}
                                className="flex items-center gap-2 mt-1"
                              >
                                <div
                                  className="w-5 h-5 opacity-70 border border-black"
                                  style={{ backgroundColor: item.color }}
                                ></div>
                                <p className="text-xs sm:text-sm">
                                  {item.label}
                                </p>
                              </div>
                            )
                          )}
                        </div>
                      )}
                    </div>

                    {/*Drainage Legends */}
                    <div className="absolute right-0 bottom-0 p-4 pointer-events-auto">
                      {!drainageLegend ? (
                        <div
                          onClick={() => setDrainageLegend(true)}
                          className="bg-white/90 px-2 py-1 rounded-r-md shadow-md cursor-pointer font-bold text-gray-800 hover:bg-white transition-colors duration-150"
                          style={{
                            writingMode: "vertical-rl",
                            textOrientation: "mixed",
                          }}
                        >
                          Drainage Legend ▶
                        </div>
                      ) : (
                        <div className="bg-white/90 p-4 rounded-md shadow-md w-full max-w-xs min-w-[220px] pointer-events-auto">
                          <div className="flex justify-between items-center mb-2">
                            <p className="text-sm font-semibold">
                              Drainage Layer Legend
                            </p>
                            <button
                              onClick={() => setDrainageLegend(false)}
                              className="text-gray-700 hover:text-black transition-colors duration-150 cursor-pointer"
                            >
                              ◀
                            </button>
                          </div>

                          {WATER_DASHBOARD_CONFIG.legends.drainage.map(
                            (item, idx) => (
                              <div
                                key={idx}
                                className="flex items-center gap-2 mt-1"
                              >
                                <div
                                  className="w-5 h-5 opacity-70 border border-black"
                                  style={{ backgroundColor: item.color }}
                                ></div>
                                <p className="text-xs sm:text-sm">
                                  {item.label}
                                </p>
                              </div>
                            )
                          )}
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              )}
            </div>
          </div>
          </div>
         
        ) : null}
      </div>
    </div>
  );
};

export default WaterProjectDashboard;

